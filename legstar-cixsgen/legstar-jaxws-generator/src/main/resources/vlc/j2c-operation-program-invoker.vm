##/////////////////////////////////////////////////////////////////////
##Jaxws Operation Invoker Template.
##@author Fady
##/////////////////////////////////////////////////////////////////////
## ==================================================================
#macro(getTransformersTypes $cixsStructures)
##
## Transformer Providers need to be imported
##
#foreach ($cixsStructure in $cixsStructures)
#set($transfomerProvider = ${cixsStructure.jaxbType} + "Transformers")
#set($newType = ${helper.getQualClassName(${cixsStructure.coxbPackageName}, ${transfomerProvider})})
#addUnique($importTypes $newType)
#end
#end
## ==================================================================
#parse("vlc/j2c-service-common-imports.vm")
## ==================================================================
## Create unique Lists of imports and Types
##
#set($importTypes = [])
#set($jaxbTypes = [])
#getImportTypes(${cixsOperation.getInput()})
#getImportTypes(${cixsOperation.getOutput()})
#getTransformersTypes(${cixsOperation.getInput()})
#getTransformersTypes(${cixsOperation.getOutput()})
## ==================================================================
#if(${cixsOperation.packageName})
package ${cixsOperation.packageName};
#end
import com.legstar.coxb.transform.HostTransformException;
#if(!$cixsOperation.hasChannel() && $cixsOperation.getOutput().size() > 1)
import com.legstar.coxb.transform.HostTransformStatus;
#end
import com.legstar.host.invoke.AbstractProgramInvoker;
import com.legstar.host.invoke.HostInvoker;
import com.legstar.host.invoke.HostInvokerException;
import com.legstar.messaging.LegStarAddress;
#if($cixsOperation.hasChannel())
import java.util.LinkedHashMap;
import java.util.Map;
#end
#foreach($importType in $importTypes)
import ${importType};
#end

/**
 * Implements an invoker for program ${cixsOperation.cicsProgramName}.
 * <p/>
 * This host program maps to operation ${cixsOperation.name}.
 * 
 * This class was generated by ${generatorName}.
 *
 */
public class ${cixsOperation.className}ProgramInvoker extends AbstractProgramInvoker {

#foreach($jaxbType in $jaxbTypes)
    /** Host transformers for ${jaxbType} java data object. */
    private ${jaxbType}Transformers m${jaxbType}Transformers;
#end

    /** Operation name for ${cixsOperation.name}. */
    private static final String  OPERATION_NAME = "${cixsOperation.name}";

    /**
     * Operation invoker constructor.
     * @param configFileName invoker configuration file name
     */
    public ${cixsOperation.className}ProgramInvoker(final String configFileName) {
        super(configFileName, OPERATION_NAME, new ${cixsOperation.className}HostProgram());
#foreach($jaxbType in $jaxbTypes)
        m${jaxbType}Transformers = new ${jaxbType}Transformers();
#end
    }

    /**
     * Invoke the ${cixsOperation.cicsProgramName} host program.
     * <p/>
     * The sequence of operations performed is:
     * <ul>
     * <li>Get an invoker for the target host address and program</li>
     * <li>Transform request data object into host bytes</li>
     * <li>Invoke the remote program</li>
     * <li>Transform reply bytes into java data object</li>
     * </ul>
     * @param address target host address
     * @param requestID a unique identifier for this request
#if($cixsOperation.getInput().size() > 0)
     * @param request the request java data object 
#end
#if($cixsOperation.getOutput().size() > 0)
     * @return the reply java data object
#end
     * @throws HostInvokerException if host invoker cannot be created or configured
     * @throws HostTransformException if transformation fails
     */
    public #if($cixsOperation.getOutput().size() > 0)$cixsOperation.responseHolderType#{else}void#end ${cixsOperation.name}(
            final LegStarAddress address,
            final String requestID#if($cixsOperation.getInput().size() > 0),
            final $cixsOperation.requestHolderType request#end)
    throws HostInvokerException, HostTransformException {

        HostInvoker hostInvoker = getHostInvoker(address);
        String hostCharset = hostInvoker.getAddress().getHostCharset();

## ------------------------------------------------------------------
## Prepare request
## -------------------------------
## -- channel driven program case:
##
#if($cixsOperation.hasChannel())
        /* Translate java objects for each container */
        Map < String, byte[] > requestParts =
            new LinkedHashMap < String, byte[] >(); 
#if($cixsOperation.getOutput().size() > 1)
#foreach ($cixsStructure in $cixsOperation.getInput())
        requestParts.put("${cixsStructure.cicsContainer}",
             get${cixsStructure.jaxbType}Transformers().toHost(
                request.get${cixsStructure.jaxbPropertyName}(), hostCharset));
#end
#end
#if($cixsOperation.getOutput().size() == 1)
        requestParts.put("${cixsOperation.getInput().get(0).cicsContainer}",
             get${cixsOperation.getInput().get(0).jaxbType}Transformers().toHost(
                request, hostCharset));
#end
#else
## -------------------------------
## -- commarea driven program case:
##
#if($cixsOperation.getInput().size() > 1)
        /* Translate java objects to separate host byte arrays */
        int byteSize = 0;
#foreach ($cixsStructure in $cixsOperation.getInput())
        byte[] ${cixsStructure.jaxbFieldName}Bytes =
             get${cixsStructure.jaxbType}Transformers().toHost(
                request.get${cixsStructure.jaxbPropertyName}(), hostCharset);
        byteSize += ${cixsStructure.jaxbFieldName}Bytes.length;
#end

        /* Merge individual byte arrays to form the request */
        byte[] requestBytes = new byte[byteSize];
        int requestBytePos = 0;

#foreach ($cixsStructure in $cixsOperation.getInput())
        System.arraycopy(${cixsStructure.jaxbFieldName}Bytes, 0, requestBytes, requestBytePos,
                ${cixsStructure.jaxbFieldName}Bytes.length);
        requestBytePos += ${cixsStructure.jaxbFieldName}Bytes.length;
#end
#end
#if($cixsOperation.getInput().size() == 1)
        /* Translate java object to a host byte array */
        byte[] requestBytes =
            get${cixsOperation.getInput().get(0).jaxbType}Transformers().toHost(request, hostCharset);
#end
#if($cixsOperation.getInput().size() == 0)
        byte[] requestBytes = null;
#end
#end

## ------------------------------------------------------------------
## Execute request
## -------------------------------
## -- channel driven program case:
##
        /* Invoke remote program */
#if($cixsOperation.hasChannel())
        Map < String, byte[] > replyParts =
            hostInvoker.invoke(requestID, requestParts);
        
#else
## -------------------------------
## -- commarea driven program case:
##
        byte[] replyBytes = hostInvoker.invoke(requestID, requestBytes);
#end

## ------------------------------------------------------------------
## Format reply
## -------------------------------
## -- channel driven program case:
##
#if($cixsOperation.hasChannel())
        /* Translate host containers to java objects */
#if($cixsOperation.getOutput().size() > 1)
        $cixsOperation.responseHolderType reply = new ${cixsOperation.responseHolderType}();
#foreach ($cixsStructure in $cixsOperation.getOutput())
        reply.set${cixsStructure.jaxbPropertyName}(
            get${cixsStructure.jaxbType}Transformers().toJava(
                replyParts.get("${cixsStructure.cicsContainer}"), hostCharset));
#end
        return reply;
#end
#if($cixsOperation.getOutput().size() == 1)
#set($cixsStructure = $cixsOperation.getOutput().get(0))
        return
            get${cixsStructure.jaxbType}Transformers().toJava(
                replyParts.get("${cixsStructure.cicsContainer}"), hostCharset);
#end
#else
## -------------------------------
## -- commarea driven program case:
##
#if($cixsOperation.getOutput().size() > 1)
        /* Translate host byte array to java objects */
        $cixsOperation.responseHolderType reply = new ${cixsOperation.responseHolderType}();
        int replyBytePos = 0;
        HostTransformStatus status = new HostTransformStatus();
#foreach ($cixsStructure in $cixsOperation.getOutput())
        reply.set${cixsStructure.jaxbPropertyName}(
            get${cixsStructure.jaxbType}Transformers().toJava(
                replyBytes, replyBytePos, hostCharset, status));
        replyBytePos += status.getHostBytesProcessed();
#end
        return reply;
#end
#if($cixsOperation.getOutput().size() == 1)
        /* Translate host byte array to a java object */
        return get${cixsOperation.getOutput().get(0).jaxbType}Transformers().toJava(replyBytes, hostCharset);
#end
#end

    }

#foreach($jaxbType in $jaxbTypes)
    /**
     * @return the host transformers for ${jaxbType}
     */
    public ${jaxbType}Transformers get${jaxbType}Transformers() {
        return m${jaxbType}Transformers;
    }

    /**
     * @param transformers the host transformers for ${jaxbType}
     */
    public void set${jaxbType}Transformers(
            final ${jaxbType}Transformers transformers) {
        m${jaxbType}Transformers = transformers;
    }

#end
}
